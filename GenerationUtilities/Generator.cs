using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace GenerationUtilities;

[Generator]
public sealed class Generator : ISourceGenerator
{
  public void Initialize(GeneratorInitializationContext context)
    => context.RegisterForSyntaxNotifications(() => new Receiver());

  public void Execute(GeneratorExecutionContext context)
  {
    if (context.SyntaxReceiver is not Receiver r) return;

    foreach (var cd in r.Candidates)
    {
      var model = context.Compilation.GetSemanticModel(cd.SyntaxTree);
      if (model.GetDeclaredSymbol(cd) is not INamedTypeSymbol symbol) continue;

      // Look for your real attribute type name (which lives in your main project)
      bool hasAttr = symbol.GetAttributes().Any(a =>
        a.AttributeClass?.ToDisplayString() == "Project.GenerationUtilities.TableSchemaAttribute");
      if (!hasAttr) continue;

      var primary = cd.ParameterList;
      if (primary is null || primary.Parameters.Count == 0) continue;

      if (symbol.InstanceConstructors.Any(c => c.Parameters.Length == 0)) continue;

      if (!cd.Modifiers.Any(m => m.Text is "partial"))
      {
        var diag = Diagnostic.Create(
          new DiagnosticDescriptor(
            id: "IEF001",
            title: "Class must be partial",
            messageFormat: "Class '{0}' is marked [TableSchema] but is not partial.",
            category: "GeneratorUtilities",
            DiagnosticSeverity.Warning,
            isEnabledByDefault: true),
          cd.Identifier.GetLocation(),
          symbol.Name);
        context.ReportDiagnostic(diag);
        continue;
      }

      var defaults = string.Join(", ", primary.Parameters.Select(_ => "default!"));

      var ns = symbol.ContainingNamespace.IsGlobalNamespace
        ? null
        : symbol.ContainingNamespace.ToDisplayString();

      var typeName = symbol.Name;
      var typeParams = symbol.TypeParameters.Length > 0
        ? "<" + string.Join(", ", symbol.TypeParameters.Select(tp => tp.Name)) + ">"
        : "";

      var sb = new StringBuilder();
      sb.AppendLine("// <auto-generated/>");
      if (!string.IsNullOrEmpty(ns))
      {
        sb.Append("namespace ").Append(ns).AppendLine(";");
        sb.AppendLine();
      }
      sb.Append("partial class ").Append(typeName).Append(typeParams).AppendLine();
      sb.AppendLine("{");
      sb.Append("    ").Append(typeName).Append("() : this(").Append(defaults).AppendLine(") { }");
      sb.AppendLine("}");

      var hintName = $"{symbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)}.CtorBridge.g.cs"
                     .Replace('<', '_').Replace('>', '_');
      context.AddSource(hintName, sb.ToString());
    }
  }

  private sealed class Receiver : ISyntaxReceiver
  {
    public System.Collections.Generic.List<ClassDeclarationSyntax> Candidates { get; } = new();
    public void OnVisitSyntaxNode(SyntaxNode node)
    {
      if (node is ClassDeclarationSyntax cd && cd.ParameterList is not null)
        Candidates.Add(cd);
    }
  }
}
